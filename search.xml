<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇编学习记录</title>
      <link href="/2023/12/07/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/12/07/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="十一·CALL框架"><a href="#十一·CALL框架" class="headerlink" title="十一·CALL框架"></a>十一·CALL框架</h2><pre><code>   EBP 寄存器 栈底指针   ESP 寄存器 栈顶指针</code></pre><h3 id="1-EBP栈底指针"><a href="#1-EBP栈底指针" class="headerlink" title="1.EBP栈底指针"></a>1.EBP栈底指针</h3><pre><code>   EBP是一个特殊的寄存器，通过EBP+偏移量 可以访问CALL里边的局部变量   它的低16位叫BP。   //EAX和AX的关系     </code></pre><h3 id="2-ESP栈顶指针"><a href="#2-ESP栈顶指针" class="headerlink" title="2.ESP栈顶指针"></a>2.ESP栈顶指针</h3><pre><code>   ESP栈顶指针与EBP栈底指针构成一段空间大小，一般就是本CALL局部变量的空间大小总和。ESP指针配合EBP使用。//SP </code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><pre><code>      （1）每个CALL会分配一个独立的栈段空间，供局部变量使用      （2）CALL栈平衡。进入CALL前与出CALL后，EBP和ESP的值不变</code></pre><h2 id="二、汇编基础知识"><a href="#二、汇编基础知识" class="headerlink" title="二、汇编基础知识"></a>二、汇编基础知识</h2><h3 id="1-机器语言（二进制语言）"><a href="#1-机器语言（二进制语言）" class="headerlink" title="1.机器语言（二进制语言）"></a>1.机器语言（二进制语言）</h3><h4 id="1-1-机器语言是机器指令的集合"><a href="#1-1-机器语言是机器指令的集合" class="headerlink" title="1.1 机器语言是机器指令的集合"></a>1.1 机器语言是机器指令的集合</h4><h3 id="2-汇编语言的产生"><a href="#2-汇编语言的产生" class="headerlink" title="2.汇编语言的产生"></a>2.汇编语言的产生</h3><h3 id="3-汇编语言的组成"><a href="#3-汇编语言的组成" class="headerlink" title="3.汇编语言的组成"></a>3.汇编语言的组成</h3><pre><code>1、汇编指令（机器码的助记符）2、伪指令   （由编译器执行）3、其它符号（由编译器识别）</code></pre><h3 id="4-存储器"><a href="#4-存储器" class="headerlink" title="4.存储器"></a>4.存储器</h3><h4 id="4-1-CPU-是计算机的核心部件．它控制整个计算机的运作并进行运算，"><a href="#4-1-CPU-是计算机的核心部件．它控制整个计算机的运作并进行运算，" class="headerlink" title="4.1 CPU 是计算机的核心部件．它控制整个计算机的运作并进行运算，"></a>4.1 CPU 是计算机的核心部件．它控制整个计算机的运作并进行运算，</h4><pre><code>  要想让一个CPU 工作，就必须向它提供指令和数据。     - 指令告诉CPU怎么运算，数据就是告诉CPU运算什么     指令和数据在存储器中存放，也就是平时所说的内存。</code></pre><h4 id="4-2-离开了内存，性能再好的CPU也无法工作。"><a href="#4-2-离开了内存，性能再好的CPU也无法工作。" class="headerlink" title="4.2 离开了内存，性能再好的CPU也无法工作。"></a>4.2 离开了内存，性能再好的CPU也无法工作。</h4><h4 id="4-3-磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，"><a href="#4-3-磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，" class="headerlink" title="4.3 磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，"></a>4.3 磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，</h4><pre><code>     就无法被CPU 使用。      硬盘 -&gt; 内存  -&gt; CPU</code></pre><h3 id="5-指令和数据"><a href="#5-指令和数据" class="headerlink" title="5.指令和数据"></a>5.指令和数据</h3><h4 id="5-1-指令和数据是应用上的概念。"><a href="#5-1-指令和数据是应用上的概念。" class="headerlink" title="5.1 指令和数据是应用上的概念。"></a>5.1 指令和数据是应用上的概念。</h4><h4 id="5-2-在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。"><a href="#5-2-在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。" class="headerlink" title="5.2 在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。"></a>5.2 在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。</h4><h4 id="5-3-二进制数据"><a href="#5-3-二进制数据" class="headerlink" title="5.3 二进制数据"></a>5.3 二进制数据</h4><pre><code>       1000    1001   1101    1000      ─&gt;   8      9      D       8    H （数据）       hex     十六进制   123456789ABCDEF       0xff   8D8H       binary  二进制              1111      2^0 + 2^1 + 2^2 + 2^3  = 15 (8+4+2+1)   0~15                  1     2     4     8                          2^4-1           总公式：   2^n - 1         4字节  2^32 - 1 = 4G                                  练习： 1011    8+2+1 = 11                   1000100111011000              ─&gt; MOV AX,BX （程序）        十进制D  [一般习惯都不加]        二进制B        八进制Q     111            十六进制H      </code></pre><h3 id="6-存储单元（Byte字节）"><a href="#6-存储单元（Byte字节）" class="headerlink" title="6.存储单元（Byte字节）"></a>6.存储单元（Byte字节）</h3><pre><code>    1KB=1024B    1MB=1024KB  1024*1024    1GB=1024MB       1TB=1024GB    </code></pre><h3 id="7-CPU对存储器和读写"><a href="#7-CPU对存储器和读写" class="headerlink" title="7.CPU对存储器和读写"></a>7.CPU对存储器和读写</h3><pre><code>    CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）    进行三类信息的交互：        存储单元的地址        （地址信息）(硬盘地址，内存地址，显卡显存地址)        器件的选择，读或写命令（控制信息）        读或写的数据          （数据信息）         地址总线    传输 地址信息         数据总线    传输 数据信息         控制总线    传输 控制信息             CPU是通过地址总线来指定存储单元的。    地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。     CPU          系统           软件程序    64          64              64           =&gt;真正的64位的运算速度        </code></pre><h3 id="8-地址总线"><a href="#8-地址总线" class="headerlink" title="8. 地址总线"></a>8. 地址总线</h3><pre><code>       一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N。              这样的CPU最多可以寻找２的N次方个内存单元。           2^n           1Byte = 8 bit       2^8 - 1 = 256 - 1  (0~255)                                 64位    8字节               </code></pre><h3 id="9-数据总线（高速公路）"><a href="#9-数据总线（高速公路）" class="headerlink" title="9.  数据总线（高速公路）"></a>9.  数据总线（高速公路）</h3><pre><code>        CPU与内存或其它器件之间的数据传送是通过数据总线来进行的。        数据总线的宽度决定了CPU和外界的数据传送速度。(传输量)</code></pre><h3 id="10-控制总线"><a href="#10-控制总线" class="headerlink" title="10. 控制总线"></a>10. 控制总线</h3><pre><code>    CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，    控制总线是一些不同控制线的集合。        有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。</code></pre><h3 id="11-内存地址空间的概念"><a href="#11-内存地址空间的概念" class="headerlink" title="11.内存地址空间的概念"></a>11.内存地址空间的概念</h3><h2 id="二、寄存器（CPU工作原理）"><a href="#二、寄存器（CPU工作原理）" class="headerlink" title="二、寄存器（CPU工作原理）"></a>二、寄存器（CPU工作原理）</h2><h3 id="1-CPU概述"><a href="#1-CPU概述" class="headerlink" title="1.CPU概述"></a>1.CPU概述</h3><pre><code>    1.1 一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。        1.2 内部总线实现CPU内部各个器件之间的联系。        1.3 外部总线实现CPU和主板上其它器件的联系。</code></pre><h3 id="2-寄存器的概述"><a href="#2-寄存器的概述" class="headerlink" title="2. 寄存器的概述"></a>2. 寄存器的概述</h3><h4 id="2-1-8086CPU有14个寄存器-它们的名称为："><a href="#2-1-8086CPU有14个寄存器-它们的名称为：" class="headerlink" title="2.1 8086CPU有14个寄存器 它们的名称为："></a>2.1 8086CPU有14个寄存器 它们的名称为：</h4><pre><code>       AX、BX、CX、DX、SI、DI、SP、BP、       IP、CS、SS、DS、ES、PSW。       这些寄存器以后会陆续介绍       </code></pre><h4 id="2-2-通用寄存器"><a href="#2-2-通用寄存器" class="headerlink" title="2.2 通用寄存器"></a>2.2 通用寄存器</h4><pre><code>       2.2.1 8086CPU所有的寄存器都是16位的，可以存放两个字节（即一个字）。            word       </code></pre><h5 id="2-2-2-AX、BX、CX、DX-通常用来存放一般性数据被称为通用寄存器。"><a href="#2-2-2-AX、BX、CX、DX-通常用来存放一般性数据被称为通用寄存器。" class="headerlink" title="2.2.2 AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器。"></a>2.2.2 AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器。</h5><h5 id="2-2-3-8086上一代CPU中的寄存器都是8位的；"><a href="#2-2-3-8086上一代CPU中的寄存器都是8位的；" class="headerlink" title="2.2.3 8086上一代CPU中的寄存器都是8位的；"></a>2.2.3 8086上一代CPU中的寄存器都是8位的；</h5><pre><code>            为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。            AX可以分为AH和AL；            BX可以分为BH和BL；            CX可以分为CH和CL；            DX可以分为DH和DL。            </code></pre><h4 id="2-3-字在寄存器中存储"><a href="#2-3-字在寄存器中存储" class="headerlink" title="2.3 字在寄存器中存储"></a>2.3 字在寄存器中存储</h4><pre><code>          word = 2Byte  </code></pre><h4 id="2-4-几条汇编指令"><a href="#2-4-几条汇编指令" class="headerlink" title="2.4 几条汇编指令"></a>2.4 几条汇编指令</h4><pre><code>        汇编指令不区分大小写           AX = 8226H    BX = 8226H           ADD AX,BX      =&gt; AX = AX + BX                          1 044C =  8226H + 8226H      044c (溢出部分将舍弃)                              注：AL的溢出不会进入AH中         </code></pre><h4 id="2-5-检测点2-1"><a href="#2-5-检测点2-1" class="headerlink" title="2.5 检测点2.1"></a>2.5 检测点2.1</h4><pre><code>      (1)         mov ax,62627       AX=F4A3H         mov ah,31H         AX=31A3H         mov al,23H         AX=3123H         add ax,ax          AX=6246H         mov bx,826CH       BX=826CH         mov cx,ax          CX=6246H         mov bx,ax          AX=826CH         add ax,bx          AX=04D8H              ax = ax + bx         mov al,bh          AX=0482H         mov ah,bl          AX=6C82H         add ah,ah          AX=D882H         add al,6           AX=D888H           add al,al          AX=D810H         mov ax,cx          AX=6246H              (2)          mov ax,2       AX=2          add ax,ax      AX=4          add ax,ax      AX=8          add ax,ax      AX=16                </code></pre><h4 id="2-6-物理地址"><a href="#2-6-物理地址" class="headerlink" title="2.6 物理地址"></a>2.6 物理地址</h4><pre><code>    CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是         一个一维的线性空间。       </code></pre><p>　    每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。            </p><h4 id="2-7-16位结构的CPU"><a href="#2-7-16位结构的CPU" class="headerlink" title="2.7 16位结构的CPU"></a>2.7 16位结构的CPU</h4><pre><code>         概括的讲，16位结构描述了一个CPU具有以下几个方面特征：            - 运算器一次最多可以处理16位的数据。            - 寄存器的最大宽度为16位。            - 寄存器和运算器之间的通路是16位的。            2^10  = 1M = 1024K     64K          </code></pre><h4 id="2-8-8086-CPU给出物理地址的方法"><a href="#2-8-8086-CPU给出物理地址的方法" class="headerlink" title="2.8 8086 CPU给出物理地址的方法"></a>2.8 8086 CPU给出物理地址的方法</h4><h5 id="2-8-1-8086有20位地址总线，可传送20位地址，寻址能力为1M。"><a href="#2-8-1-8086有20位地址总线，可传送20位地址，寻址能力为1M。" class="headerlink" title="2.8.1 8086有20位地址总线，可传送20位地址，寻址能力为1M。"></a>2.8.1 8086有20位地址总线，可传送20位地址，寻址能力为1M。</h5><h5 id="2-8-2-8086内部为16位结构，它只能传送16位的地址，"><a href="#2-8-2-8086内部为16位结构，它只能传送16位的地址，" class="headerlink" title="2.8.2 8086内部为16位结构，它只能传送16位的地址，"></a>2.8.2 8086内部为16位结构，它只能传送16位的地址，</h5><pre><code>              表现出的寻址能力却只有64K。          </code></pre><h5 id="2-8-3-8086CPU采用一种在内部用两个16位地址合成的方法来形成"><a href="#2-8-3-8086CPU采用一种在内部用两个16位地址合成的方法来形成" class="headerlink" title="2.8.3 8086CPU采用一种在内部用两个16位地址合成的方法来形成"></a>2.8.3 8086CPU采用一种在内部用两个16位地址合成的方法来形成</h5><pre><code>              一个20位的物理地址。        </code></pre><h5 id="2-8-4-地址加法器合成物理地址的方法：-血汗工厂"><a href="#2-8-4-地址加法器合成物理地址的方法：-血汗工厂" class="headerlink" title="2.8.4 地址加法器合成物理地址的方法： (血汗工厂)"></a>2.8.4 地址加法器合成物理地址的方法： (血汗工厂)</h5><pre><code>               物理地址 = 段地址×16 + 偏移地址                 20          16+4=20        16                             1111 1111 1111 1111                     1111 1111 1111 1111 0000                     </code></pre><h5 id="2-8-5-由段地址X16引发的讨论"><a href="#2-8-5-由段地址X16引发的讨论" class="headerlink" title="2.8.5 由段地址X16引发的讨论"></a>2.8.5 由段地址X16引发的讨论</h5><pre><code>        （1）一个数据的二进制形式左移1位，相当于该数据乘以2；        （2）一个数据的二进制形式左移N位，相当于该数据乘以2的N次方；        （3）地址加法器如何完成段地址×16的运算？                 以二进制形式存放的段地址左移4位。                 0111        7                 1110        14     7*2  乘以2相当于左移1位             0111 0000        112    7*16     乘以16相当于左移4位                          一个数据的八进制形式左移1位，相当于该数据乘以8              一个数据的十进制形式左移1位，相当于该数据乘以10              一个数据的十六进制形式左移1位，相当于该数据乘以16            </code></pre><h4 id="2-9-段的概念"><a href="#2-9-段的概念" class="headerlink" title="2.9 段的概念"></a>2.9 段的概念</h4><pre><code>        错误认识：        内存被划分成了一个一个的段，每一个段有一个段地址。                     其实：         内存并没有分段，段的划分来自于CPU，由于8086CPU用         “（段地址×16）+偏移地址=物理地址”的方式给出内存单元的物理地址，                  使得我们可以用分段的方式来管理内存。                以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，            用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。           （1）段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数；                  （2）偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。     检测点2.2    物理地址 = 段地址*16 + 偏移地址      偏移量：0 ~ FFFFH    （1） MAX : 0001H * 16 + FFFFH = 0010H + FFFFH =  1000FH          MIN : 0001H * 16 + 0     = 0010H  + 0  =    10H                10H ~ 1000FH           (2) 物理地址： 20000H    ( y = a*16 + b )  (y = 20000H  0&lt;= b &lt;= FFFFH  求a的范围?)                偏移量为0     偏移量位FFFFH                  段地址     2000H        1001H             最小为：1001H      最大为：2000H                           </code></pre><h4 id="2-10-段寄存器"><a href="#2-10-段寄存器" class="headerlink" title="2.10 段寄存器"></a>2.10 段寄存器</h4><h5 id="2-10-1-段寄存器就是提供段地址的。"><a href="#2-10-1-段寄存器就是提供段地址的。" class="headerlink" title="2.10.1 段寄存器就是提供段地址的。"></a>2.10.1 段寄存器就是提供段地址的。</h5><pre><code>                 8086CPU有4个段寄存器：                   CS、DS、SS、ES                   Code segment        Data segment                   Stack segment       Extract segment                                     当8086CPU要访问内存时，由这4个段寄存                  器提供内存单元的段地址。        </code></pre><h4 id="2-11-CS和IP寄存器-（8086都是16位）"><a href="#2-11-CS和IP寄存器-（8086都是16位）" class="headerlink" title="2.11 CS和IP寄存器 （8086都是16位）"></a>2.11 CS和IP寄存器 （8086都是16位）</h4><pre><code>          CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。                - CS为代码段寄存器；                - IP为指令指针寄存器     </code></pre><h4 id="2-12-8086-PC工作的过程"><a href="#2-12-8086-PC工作的过程" class="headerlink" title="2.12 8086 PC工作的过程"></a>2.12 8086 PC工作的过程</h4><pre><code>             2.12.1 8086 PC读取和执行指令相关流程          </code></pre><h5 id="2-12-2-8086-PC工作过的的描述"><a href="#2-12-2-8086-PC工作过的的描述" class="headerlink" title="2.12.2 8086 PC工作过的的描述"></a>2.12.2 8086 PC工作过的的描述</h5><pre><code>          （1）从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；    （2）IP = IP + 所读取指令的长度，从而指向下一条指令；    （3）执行指令。 转到步骤 （1），重复这个过程。                 在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置    为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元    中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。          改变CS和IP的值就可以控制CPU的执行的指令     </code></pre><h5 id="2-12-3-CPU根据什么将内存中的信息看作指令？"><a href="#2-12-3-CPU根据什么将内存中的信息看作指令？" class="headerlink" title="2.12.3 CPU根据什么将内存中的信息看作指令？"></a>2.12.3 CPU根据什么将内存中的信息看作指令？</h5><pre><code>                      CPU将CS:IP指向的内存单元中的内容看作指令。</code></pre><h4 id="2-13-修改CS和IP的指令"><a href="#2-13-修改CS和IP的指令" class="headerlink" title="2.13 修改CS和IP的指令"></a>2.13 修改CS和IP的指令</h4><pre><code>          在CPU中，程序员能够用指令读写的部件只有寄存器，    程序员可以通过改变寄存器中的内容实现对CPU的控制。    CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通    过改变CS、IP中的内容来控制CPU执行目标指令。    我们如何改变CS、IP的值呢？    (1)同时修改CS、IP的内容：    jmp 段地址：偏移地址    jmp 2AE3:3       =&gt;2AE3H * 16 + 3 = 2AE33H    jmp 3:0B16       =&gt;3*16   + 0B16  = 0B46H          功能：用指令中给出的段地址修改CS，偏移地址修改IP。                              (2) 仅修改IP的内容：    jmp 某一合法寄存器    jmp ax   （类似于 mov IP,ax）    jmp bx       功能：用寄存器中的值修改IP。</code></pre><h4 id="2-14-问题分析"><a href="#2-14-问题分析" class="headerlink" title="2.14 问题分析"></a>2.14 问题分析</h4><pre><code>          （1）mov ax,6622H          (2) jmp 1000:3          (3) mov ax,0000          (4) mov bx,ax          (5) jmp bx          (6) mov ax,0123H          (7) 转到第(3)步执行          </code></pre><h4 id="2-15-代码段"><a href="#2-15-代码段" class="headerlink" title="2.15 代码段"></a>2.15 代码段</h4><pre><code>      对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。      可以将长度为 N（ N≤64KB ）的一组代码，存在一组地址连续、起始地址为 16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。如何使得代码段中的指令被执行呢？       将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，       就自动地将我们定义得代码段中的指令当作指令来执行。       CPU 只认被 CS:IP 指向的内存单元中的内容为指令。       所以要将CS:IP指向所定义的代码段中的第一条指令的首地址。       CS = 123BH，IP = 0000H。</code></pre><h4 id="2-16-检测点3"><a href="#2-16-检测点3" class="headerlink" title="2.16 检测点3"></a>2.16 检测点3</h4><pre><code>   修改4次:       第一次在CPU读取&quot;mov ax,bx&quot;后       第二次在CPU读取&quot;sub ax,ax&quot;后    第三次在CPU读取&quot;jmp ax&quot;后    第四次在CPU执行完&quot;jmp ax&quot;后；    IP最后的值为0                          </code></pre><h4 id="2-17-实验1"><a href="#2-17-实验1" class="headerlink" title="2.17 实验1"></a>2.17 实验1</h4><pre><code>          r 查看和修改寄存器的值    r   查看寄存器的值    r ax(cs ip等)修改寄存器ax(cs ip等)的值                    d 查看内存中内容     d  1000:0  1f    (1f表示范围)                 e 修改内存的内容    e 1000:0  30 31 32 33 34 35 36 37   （一次性修改）    e 1000:0  &#39;a&#39; &#39;b&#39; &#39;c&#39;                   e 1000:0                             (询问式修改)                   u  以汇编指令的形式查看机器码    u   1000:0   1f     (1f表示范围)             写入指令:    方式1： e 1000:0  b8 01 00 b9 02 00 01 08    方式2： a 1000:0                          以汇编指令的形式写入                 t  执行下一条指令(执行之前可以通过r命令修改cs:ip的值)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇文章</title>
      <link href="/2023/11/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
      <url>/2023/11/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<pre><code>终于创建成功了！！！！！！！</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/27/hello-world/"/>
      <url>/2023/11/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
